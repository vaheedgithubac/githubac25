# Expense Microservice Deployment ðŸš€

GitOps-based deployment of the Expense microservice using **Argo CD**, **Helm**, and **ApplicationSet**.

---

## Git Repo Structure

```text
expense/
â””â”€â”€ cd/
    â””â”€â”€ argocd/
        â””â”€â”€ dev/
            â”œâ”€â”€ frontend/
            â”‚   â””â”€â”€ helm/
            â”‚       â”œâ”€â”€ Chart.yaml
            â”‚       â”œâ”€â”€ values.yml
            â”‚       â””â”€â”€ templates/
            â”‚           â”œâ”€â”€ deployment.yaml
            â”‚           â””â”€â”€ service.yaml
            â”œâ”€â”€ backend/
            â”‚   â””â”€â”€ helm/
            â”‚       â”œâ”€â”€ Chart.yaml
            â”‚       â”œâ”€â”€ values.yml
            â”‚       â””â”€â”€ templates/
            â”‚           â”œâ”€â”€ deployment.yaml
            â”‚           â””â”€â”€ service.yaml
            â””â”€â”€ database/
                â””â”€â”€ helm/
                    â”œâ”€â”€ Chart.yaml
                    â”œâ”€â”€ values.yml
                    â””â”€â”€ templates/
                        â”œâ”€â”€ deployment.yaml
                        â”œâ”€â”€ service.yaml
                        â””â”€â”€ pvc.yaml
```

## STEP 0ï¸âƒ£ â€” Assumptions

ðŸ‘‰ Kubernetes cluster exists  
ðŸ‘‰ Argo CD is installed in the `argocd` namespace  
ðŸ‘‰ You have access to a Git repository  
ðŸ‘‰ You have SMTP credentials to send emails  
ðŸ‘‰ We will configure the Argo CD Notifications controller using a **Kubernetes Secret** for email credentials  

## STEP 1ï¸âƒ£ â€” Install Argo CD Notifications Controller

Install the Notifications controller in the `argocd` namespace:

```bash
kubectl apply -n argocd -f https://raw.githubusercontent.com/argoproj-labs/argocd-notifications/stable/manifests/install.yaml
```
Check that the Notifications controller pods are running:
```bash
kubectl get pods -n argocd

NAME                                   READY   STATUS    RESTARTS   AGE
argocd-notifications-controller-xxxxx  1/1     Running   0          1m
```
## STEP 2ï¸âƒ£ â€” Create Secret for Email

We donâ€™t store passwords in plain ConfigMaps. Letâ€™s create a **Kubernetes Secret** for Argo CD Notifications in `argocd` namespace:

```yaml
apiVersion: v1
kind: Secret
metadata:
  name: argocd-notifications-secret
  namespace: argocd
stringData:
  smtp-host: smtp.example.com
  smtp-port: "587"
  smtp-from: argocd@example.com
  smtp-username: argocd@example.com
  smtp-password: examplepassword
```
Apply it:
```bash
kubectl apply -f argocd-notifications-secret.yaml
```

## STEP 3ï¸âƒ£ â€” Create ConfigMap for Notifications Controller

Create a **ConfigMap** to configure notification templates and triggers for Argo CD:

```yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: argocd-notifications-cm
  namespace: argocd
data:
  service.email: |
    host: $smtp-host
    port: $smtp-port
    from: $smtp-from
    username: $smtp-username
    password: $smtp-password

  # Notification templates
  template.app-deployed: |
    message: "Application {{.app.metadata.name}} deployed successfully"
    subject: "[ArgoCD] {{.app.metadata.name}} Deployed"

  template.app-health-degraded: |
    message: "Application {{.app.metadata.name}} is degraded"
    subject: "[ArgoCD] {{.app.metadata.name}} Health Degraded"

  template.app-sync-failed: |
    message: "Application {{.app.metadata.name}} sync failed"
    subject: "[ArgoCD] {{.app.metadata.name}} Sync Failed"

  # Notification triggers
  trigger.on-deployed: |
    - description: Application successfully deployed
    - send: [app-deployed]

  trigger.on-health-degraded: |
    - description: Application degraded
    - send: [app-health-degraded]

  trigger.on-sync-failed: |
    - description: Application sync failed
    - send: [app-sync-failed]
```

Apply the ConfigMap:
```bash
kubectl apply -f argocd-notifications-cm.yaml
```
### Explanation
ðŸ‘‰ `service.email` â†’ Uses environment variables from the Secret  
ðŸ‘‰ `template.*` â†’ Defines email subject & body  
ðŸ‘‰ `trigger.*` â†’ Maps Argo CD events to templates  
ðŸ‘‰ Now `on-sync-failed` exists and matches ApplicationSet annotations

## STEP 4ï¸âƒ£ â€” Link ConfigMap with Secret

The Notifications controller automatically resolves environment variables from Secrets if properly mounted.  
You may need to patch the Deployment to ensure it reads from the Secret:

```bash
kubectl patch deployment argocd-notifications-controller -n argocd --patch '{
  "spec": {
    "template": {
      "spec": {
        "containers": [{
          "name": "argocd-notifications-controller",
          "envFrom": [{
            "secretRef": { "name": "argocd-notifications-secret" }
          }]
        }]
      }
    }
  }
}'
```
Now restart the controller: 
```bash
kubectl rollout restart deployment argocd-notifications-controller -n argocd
```
âœ… Now Notifications controller can read SMTP credentials securely.

## STEP 5ï¸âƒ£ â€” AppProject with ClusterResourceWhitelist

Create an **AppProject** in Argo CD to group and manage all Expense microservice applications, define allowed Git repos, destinations, and roles:

`AppProject.yml`
```yaml
apiVersion: argoproj.io/v1alpha1
kind: AppProject
metadata:
  name: expense-project
  namespace: argocd
spec:
  description: Project for expense microservice

  sourceRepos:
    - "https://github.com/my-org/my-repo.git"

  destinations:
    - namespace: "expense-*"
      server: https://kubernetes.default.svc

  clusterResourceWhitelist:
    - group: ""
      kind: "Namespace"

  namespaceResourceWhitelist:
    - group: "*"
      kind: "*"

  roles:
    - name: frontend-admin
      policies:
        - p, proj:expense:frontend-admin, applications, *, expense/expense-*-frontend, allow

    - name: backend-admin
      policies:
        - p, proj:expense:backend-admin, applications, *, expense/expense-*-backend, allow

    - name: database-admin
      policies:
        - p, proj:expense:database-admin, applications, *, expense/expense-*-database, allow

    - name: expense-admin
      policies:
        - p, proj:expense:expense-admin, applications, *, expense/*, allow
```
### Explanation

ðŸ‘‰ `clusterResourceWhitelist` â†’ Allows Helm charts to deploy ClusterRole, CRDs, etc.  
ðŸ‘‰ `namespaceResourceWhitelist` â†’ Allows namespace-level objects  
ðŸ‘‰ `destinations` â†’ Only "expense-*" namespace (or matching `expense-*`) is allowed

Apply the yaml file
```bash
kubectl apply -f AppProject.yml
```

## STEP 6ï¸âƒ£ â€” ApplicationSet for Components with Notifications

Create an **ApplicationSet** to deploy all Expense microservice components (frontend, backend, database) per environment, with **component-specific notifications** and **sync waves**:

`ApplicationSet`
```yaml
apiVersion: argoproj.io/v1alpha1
kind: ApplicationSet
metadata:
  name: expense-applicationset
  namespace: argocd
spec:
  generators:
    - matrix:
        generators:
          - list:
              elements:
                - env: dev
                #- env: stage
                #- env: prod
          - git:
              repoURL: https://github.com/my-org/my-repo.git
              revision: main
              directories:
                - path: cd/argocd/{{env}}/*
  template:
    metadata:
      name: expense-{{env}}-{{path.basename}}
      namespace: argocd
      labels:
        env: "{{env}}"
        project: expense
        component: "{{path.basename}}"

      annotations:
        # ðŸ”¹ SYNC WAVES (CRITICAL)
        argocd.argoproj.io/sync-wave: >
          {{- if eq path.basename "database" -}}0
          {{- else if eq path.basename "backend" -}}1
          {{- else if eq path.basename "frontend" -}}2
          {{- end }}

        # ðŸ”¹ Notifications
        notifications.argoproj.io/subscribe.on-deployed.email: "expense-{{env}}-{{path.basename}}@example.com"
        notifications.argoproj.io/subscribe.on-health-degraded.email: "expense-{{env}}-{{path.basename}}@example.com"
        notifications.argoproj.io/subscribe.on-sync-failed.email: "expense-{{env}}-{{path.basename}}@example.com"

    spec:
      project: expense-project

      source:
        repoURL: https://github.com/my-org/my-repo.git
        targetRevision: main
        path: "{{path}}/helm"
        helm:
          valueFiles:
            - values.yml

      destination:
        server: https://kubernetes.default.svc
        namespace: "expense-{{env}}"

      syncPolicy:
        automated:
          prune: true          # delete resources not in Git
          selfHeal: true       # revert out-of-band changes
        syncOptions:
          - CreateNamespace=true
          - ApplyOutOfSyncOnly=true
          - ServerSideApply=true
          - PruneLast=true
```




